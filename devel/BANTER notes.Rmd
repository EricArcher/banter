---
title: "BANTER Notes"
output:
  html_notebook: default
---
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  comment = "", 
  echo = TRUE,
  fig.align = "left",
  error = TRUE
)
```

### Problems

#### Memory for detector classifiers and distillation
We had memory issues running the detector randomForest models, so we "distilled" each detector down to a manageable number. This involved doing some clustering and finding representative calls for each cluster. In order to do the clustering we had to create a distance matrix and in order to do that, we had to know which measures should be log-transformed so the Euclidean distances made sense.  
How do we do know this ahead of time, and without requiring the users to enter it for every measure (they might get it wrong)? Howabout a simple goodness-of-fit comparison for each measure imported?

#### Keeping data with classifiers
Do we need to keep the data with the classification models? Can come in handy later for summaries, but takes up memory that we may need for classification models.

#### Keeping detector metadata
Do we need to retain detector metadata (settings, datetime run, user, etc.)? 

#### How generic should the algorithm be?
Should we closely tie this to PAMr data.types, such that we don't retain original data and use the same names/naming schemes? Do we assume BANTER will always be used with acoustic data? Always data from PAMGUARD? Could it be any set of hierachical predictors? Always classifying to species?


### S4 classes for BANTER

#### detector
Contains information from a detector for a given call type (e.g., clicks). Slots:

* `info`: list of information about the detector. must have unique `name`, but also can include username, date/time run, detector settings, etc. May change to just a slot for 'name' if retaining extra metadata isn't necessary.
* `data`: data.frame with one row per call. May optionally be a filename if full data is too big to stay in memory with everything else. Columns are:
    + `event.id`
    + `call.id`: must be unique for detector.
    + every column after is a measurement of call `call.id` from the detector.  
* `model`: randomForest or rfPermute model object.

```{r}
setClassUnion("classifier", c("randomForest", "rfPermute", "ranger", "NULL"))

setClass(
  "banter_detector",
  slots = c(
    info = "list",
    data = "data.frame",
    model = "classifier"
  )
)

setValidity(
  "banter_detector",
  method = function(object) {
    valid <- NULL
    
    # Check @info -----------------------
    if(!"name" %in% names(object@info)) {
      valid <- c(valid, "'info' must contain an element called 'name'")
    }
    
    # Check @data -----------------------
    has.event.id <- "event.id" %in% colnames(object@data)
    has.call.id <- "call.id" %in% colnames(object@data)
    if(!has.event.id) {
      valid <- c(valid, "'data' must contain a column called 'event.id'")
    }
    if(!has.call.id) {
      valid <- c(valid, "'data' must contain a column called 'call.id'")
    }
    if(has.event.id & has.call.id & ncol(object@data) == 2) {
      valid <- c(valid, "'data' must have predictor columns")
    }
      
    # Check @model ----------------------
    if(!is.null(model)) {
      # check that model is compatabile with data
    }
    
    if(is.null(valid)) TRUE else valid
  }
)
```

#### events
Contains information about all events. Slots:

* `data`: data.frame of data used to train the model with one row per event. Should be able to keep this data.frame in memory, but can store filename if too big. Columns are:

    + `event.id`
    + `species`
    + every column after is event-specific data to be used in event-level classifier.
* `detectors`: named list of `detector` objects
* `is.training`: logical - are these events for training the model? Must be set when object is made and cannot be changed.
    + `TRUE`: any rows with `NA` in the `species` column of `@data` are deleted.
    + `FALSE`: the `model` slot here and in each element in `@detectors` must be `NULL` and the `species` column in `@data` must have all `NAs`.
* `model`: randomForest or rfPermute model object.

#### prediction
Contains species predictions for events where `@is.training` is `FALSE`. Slots:

* `preds`: data.frame with the following columns:  
    + `event.id`: in same order as in `events@test`.
    + `species`: predicted species
    + `prob.spp`: one column with the assignment probability for each species "spp"

### Accessor functions

* `detectorInfo(events, detector, info)`: load metadata information for detector.
* `detectorData(events, detector, data)`: load data from detector for each call.
* `eventData(events)`: load data for events.

### Classification functions
* `createClassifier(events)`: master runner for running both detector and event classification models.
* `detectorProportion(events)`: loads events with total proportion of calls for each detector in an event.  
* `assignmentMeans`: loads events with matrix of assignment probability means from each detector classifier for each event.
* `predict(object, test.events, ...)`: S3 method for `events` object. `test.events` is an `events` object where `@is.training` is `FALSE`.

### Summary functions
* `summary`: S3 methods for detectors, events, and predictions. 
* `plot`: S3 methods of summary plots for detector and event classifiers, and predictions.

